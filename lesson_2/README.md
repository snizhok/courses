# Системы контроля версий (VCS)

Система контроля версий — это система, регистрирующая изменения в одном или нескольких файлах с тем, чтобы в дальнейшем была возможность вернуться к определённым старым версиям этих файлов.

Система контроля версий даёт возможность возвращать отдельные файлы к прежнему виду, возвращать к прежнему состоянию весь проект, просматривать происходящие со временем изменения, определять, кто последним вносил изменения во внезапно переставший работать модуль, кто и когда внёс в код какую-то ошибку, и многое другое. Вообще, если, пользуясь СКВ, вы всё испортите или потеряете файлы, всё можно будет легко восстановить.

## Распределённые системы контроля версий

В таких системах клиенты не просто выгружают последние версии файлов, а полностью копируют весь репозиторий. Поэтому в случае, когда "умирает" сервер, через который шла работа, любой клиентский репозиторий может быть скопирован обратно на сервер, чтобы восстановить базу данных. Каждый раз, когда клиент забирает свежую версию файлов, он создаёт себе полную копию всех данных.

![git](img/git.png)

Кроме того, в большей части этих систем можно работать с несколькими удалёнными репозиториями, таким образом, можно одновременно работать по-разному с разными группами людей в рамках одного проекта. Так, в одном проекте можно одновременно вести несколько типов рабочих процессов, что невозможно в централизованных системах.

## Основы Git

Git считает хранимые данные набором слепков небольшой файловой системы. Каждый раз, когда вы фиксируете текущую версию проекта, Git, по сути, сохраняет слепок того, как выглядят все файлы проекта на текущий момент. Ради эффективности, если файл не менялся, Git не сохраняет файл снова, а делает ссылку на ранее сохранённый файл.

![git1](img/git1.png)

Для совершения большинства операций в Git'е необходимы только локальные файлы и ресурсы, т.е. обычно информация с других компьютеров в сети не нужна. 

Вы можете определенное время работать без подключения к сети, используя только локальный репозиторий. Вносить изменения, делать комиты. А потом просто сделать синхронизацию с сервером.

Практически все действия, которые вы совершаете в Git'е, только добавляют данные в базу. Очень сложно заставить систему удалить данные или сделать что-то необратимое. Можно, потерять данные, которые вы ещё не сохранили, но как только они зафиксированы, их очень сложно потерять, особенно если вы регулярно отправляете изменения в другой репозиторий.

Стандартный рабочий процесс с использованием Git'а выглядит примерно так:

* Вы вносите изменения в файлы.
* Подготавливаете файлы, добавляя их слепки в индекс.
* Делаете коммит, который берёт подготовленные файлы из индекса и помещает их в каталог Git'а на постоянное хранение.

## Работа с [GIT](https://git-scm.com/book/ru/v2)

### Установка git

```
$ apt install git
```

###  Установка вашего username/email для Git

Установка глобальных значений

```
$ git config --global user.name "John Doe"
$ git config --global user.email "jdoe@mail.com"
```

Установка для определенного репозитория

```
$ git config user.name "John Doe"
$ git config user.email "jdoe@mail.com"
```

### Инициализация репозитория

```
$ git init
```

Эта команда создаёт в текущем каталоге новый подкаталог с именем .git содержащий все необходимые файлы репозитория — основу Git-репозитория. На этом этапе ваш проект ещё не находится под версионным контролем.

Чтобы добавить под версионный контроль существующие файлы, вам нужно проиндексировать эти файлы и осуществить первую фиксацию изменений. Осуществить это вы можете с помощью команд `git add` указывающей индексируемые файлы, а затем `git commit` фиксирующей изменения.

```
$ git add .
$ git commit -m 'initial project version'
```

Добавление параметра `-a` в команду `git commit` заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без `git add` 

```
$ git commit -a -m 'initial project version'
```

### Клонирование существующего репозитория

```
$ git clone https://github.com/libgit2/libgit2 ./
```

Эта команда склонирует репозиторий libgit2/libgit2 в текущую папку.

### Запись изменений в репозиторий

Все файлы в проекте могут находится в двух состояниях: *отслеживаемые* и *неотслеживаемые*. Отслеживаемые файлы — это те файлы, которые были в последнем слепке состояния проекта; они могут быть неизменёнными, изменёнными или подготовленными к коммиту. Неотслеживаемые файлы — это всё остальное, любые файлы в вашем рабочем каталоге.

![git3](img/git3.png)

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда `git status`.

```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   2.txt

Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    4.txt
        modified:   1.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        3.txt
```

### Работа с удалёнными репозиториями

Просмотр удалённых репозиториев:

```
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
```

Добавление удалённых репозиториев:


```
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)
```

Получение изменений из удалённого репозитория - Fetch и Pull:

```
$ git fetch origin
$ git fetch origin master
```

Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта. Теперь эти ветки в любой момент могут быть просмотрены или слиты.

```
$ git pull origin master
```

Выполнение `git pull`, как правило, извлекает (*fetch*) данные с сервера, с которого вы изначально склонировали, и автоматически пытается слить (*merge*) их с кодом, над которым вы в данный момент работаете. Этот способ может для вас оказаться более простым или более удобным.

Отправка изменений в удалённый репозиторий - Push:

```
$ git push origin master
```

### Основы ветвления и слияния

Команда `git branch` выводит список веток

```
$ git branch
  dev
* master
  testing
```

Предположим, вы работаете над проектом и у вас уже есть несколько коммитов.

![git4](img/git4.png)

Затем вам приходит новая задача *ISS-53*. Чтобы создать ветку и сразу переключиться на нее, можно выполнить команду `git checkout` с параметром `-b`

```
$ git checkout -b iss53
Switched to a new branch "iss53"
```
или

```
$ git branch iss53
$ git checkout iss53
```

![git5](img/git5.png)

Далее вы выполняете определенные изменения и делаете новый коммит.

```
$ git commit -a -m 'added a new footer ISS-53'
```

![git6](img/git6.png)

И тут прибегает ПМ и говорит, что нужно срочно сделать маленькую правку. Вы переключаетесь на основную ветку

```
$ git checkout master
Switched to branch 'master'
```
Сейчас ваш рабочий проект вернется к состоянию, в котором он был в момент последнего коммита в ветку *master*.

Теперь можем перейти к написанию исправления. Для этого создадим новую ветку, в которой будем работать, пока не закончим исправление.

```
$ git checkout -b hotfix
Switched to a new branch 'hotfix'
...
$ git commit -a -m 'fixed'
[hotfix 1fb7853] fixed
 1 file changed, 2 insertions(+)
```

![git7](img/git7.png)

Проверяем, все работает как надо. Теперь нужно применить эти изменения для ветки *master*. Для этого необходимо выполнить слияние веток.

Делается это командой `git merge`

```
$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
index.html | 2 ++
1 file changed, 2 insertions(+)
```

![git8](img/git8.png)

Отлично, хотфикс внедрили. Теперь нужно прибраться за собой. Удалим ветку *hotfix* за ненадобностью. 

```
$ git branch -d hotfix
Deleted branch hotfix (3a0874c).
``` 

Теперь вернeмся к работе над своей задачей:

```
$ git checkout iss53
Switched to branch "iss53"
...
$ git commit -a -m 'finished the new footer ISS-53'
[iss53 ad82d7a] finished the new footer ISS-53
1 file changed, 1 insertion(+)
```

![git9](img/git9.png)

Закончили с задачей и теперь хотим залить свои изменения в основную ветку. Выполняем такие же манипуляции, как и с веткой *hotfix*

```
$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
```

Гит в этом случае автоматически сделает так называемый коммит слияния.

![git10](img/git10.png)

И опять уборка:

```
$ git branch -d iss53
```

### Ахтунг - конфликты

Если вы изменили одну и ту же часть одного и того же файла по-разному в двух объединяемых ветках, Git не сможет их чисто объединить.

Допустим, что мы в ветке *iss53* изменили ту же часть файла, что и в ветке *hotfix*. Тогда при слиянии ветки *master* с веткой *iss53* возникнет конфликт.

```
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
```

Итак, закатываем рукава и идем править конфликты. Чтобы в любой момент после мерджа увидеть файлы с конфликтами можно выполнить команду `git status`

```
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")
``` 

Посмотрим что же из себя представляет конфликт. Откроем файл *index.html* и здравствуй елка, Новый год:

```
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
```

Заменяем елочку на правильный вариант

```
<div id="footer">
 please contact us at support@github.com
</div>
```

либо придумываем что-то новенькое

```
<div id="footer">
please <a href="mailto:email.support@github.com">contact us</a> 
</div>
```

Разрешив каждый конфликт во всех файлах, запустите `git add` для каждого файла, чтобы отметить конфликт как решенный. Подготовка (staging) файла помечает его для Git как разрешенный конфликт.

```
$ git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

    modified:   index.html
```

Создадим коммит слияния:

```
$ git commit -m "iss53 merged into master"
```
___

[Учебник Git](https://git-scm.com/book/ru/v2/)
