# [Основы синтаксиса и типы](https://www.php.net/manual/ru/language.types.php)

## Синтаксис

Когда PHP обрабатывает файл, он ищет открывающие и закрывающие теги `<?php ... ?>`, которые указывают PHP, когда начинать и заканчивать обработку кода между ними. Подобный способ обработки позволяет PHP внедряться во все виды различных документов, так как всё, что находится вне пары открывающих и закрывающих тегов, будет проигнорировано парсером PHP.

Если файл содержит только код PHP, предпочтительно опустить закрывающий тег в конце файла. Это помогает избежать добавления случайных символов пробела или перевода строки после закрывающего тега PHP, которые могут послужить причиной нежелательных эффектов, так как PHP начинает выводить данные в буфер при отсутствии намерения у программиста выводить какие-либо данные в этой точке скрипта.

```php
<?php 
    echo 'если вы хотите хранить код PHP в документах HTML или XML, то используйте эти теги'; 
?>
```

Вы также можете встретить короткие теги  `<? ... ?>`, которые лучше не использовать, так как для этого необходимо дополнительно настраивать php. По умолчанию они отключены.

Кроме того очень удобно использовать комбинорование тега открытия `<?php` и тега вывода `echo`:

```php
<?= 'напечатать эту строку' ?>
или
<?php echo 'напечатать эту строку' ?>
```

PHP требует окончания инструкций точкой запятой в конце каждой инструкции. 

Закрывающий тег блока PHP-кода автоматически применяет точку с запятой; т.е. нет необходимости ставить точку с запятой в конце последней строки блока с PHP-кодом.

PHP поддерживает комментарии в стиле 'C', 'C++' и оболочки Unix (стиль Perl). Например:

```php
<?php
    echo "..."; // Это однострочный комментарий в стиле C++
    /* Это многострочный комментарий,
       еще одна строка комментария */
    echo "..."; # Это комментарий в стиле оболочки Unix
?>
```

Многострочные комментарии нельзя вкладывать друг в друга, так как комментарий заканчивается при первом же закрывающем символе `*/`

```php
<?php
 /*
    echo "Это тест"; /* Этот комментарий вызовет проблему */
 */
?>
```

## Типы

PHP - нестрого типизированный язык. 

PHP не требует (и не поддерживает) явного типа при определении переменной; 
тип переменной определяется по контексту, в котором она используется. 
Это означает, что мы можем использовать одну и ту же переменную для присвоения значений разных типов.
То есть, если вы присвоите значение типа string переменной $var, то $var изменит тип на string. 
Если вы затем присвоите $var значение типа integer, она станет целым числом (integer).

*PHP поддерживает десять простых типов.*

Четыре скалярных типа:

* boolean
* integer
* float (число с плавающей точкой)
* string

Четыре смешанных типа:

* array
* object
* callable
* iterable

И два специальных типа:

* resource
* NULL

### Boolean

Логический тип данных, или булевый тип выражает истинность значения. Он может принимать значение TRUE, либо FALSE.

Для указания boolean, используюся константы `TRUE` или `FALSE`. Обе они регистронезависимы.

При преобразовании в boolean, следующие значения рассматриваются как FALSE:

* само значение boolean FALSE
* integer 0 (ноль) и -0 (минус ноль)
* float 0.0 (ноль) и -0.0 (минус ноль)
* пустая строка, и строка "0"
* массив без элементов
* особый тип NULL (включая неустановленные переменные)

Все остальные значения рассматриваются как TRUE.

### Целые числа

Это числа из множества -N ..., -2, -1, 0, 1, 2, ... N.

Размер типа integer зависит от платформы, хотя, как правило, максимальное значение примерно равно 2 миллиардам (это 32-битное знаковое). 
64-битные платформы обычно имеют максимальное значение около 9E18, кроме Windows, которая всегда 32-битная.

Если PHP обнаружит, что число превышает размер типа integer, он будет интерпретировать его в качестве float. 
Аналогично, если результат операции лежит за границами типа integer, он будет преобразован во float.

Для явного преобразования в integer, используйте приведение `(int)123` или `(integer)123`. Однако, в большинстве случаев, в приведении типа нет необходимости, 
так как значение будет автоматически преобразовано, если оператор, функция или управляющая структура требует аргумент типа integer. 
Значение также может быть преобразовано в integer с помощью функции `intval('123')`.

* FALSE преобразуется в 0 (ноль), а TRUE - в 1 (единицу)
* Значение NULL всегда преобразуется в 0 (ноль)
* При преобразовании из float в integer, число будет округлено в сторону нуля
* Если строка начинается с верного числового значения, будет использовано это значение. 
Иначе значением будет 0 (ноль). 

*Для других типов поведение преобразования в integer не определено.*

### Числа с плавающей точкой

Числами с плавающей точкой для простоты назовем числа с дробной частью.

Размер числа с плавающей точкой зависит от платформы, хотя максимум, как правило, 
составляет 1.8e308 с точностью около 14 десятичных цифр (64-битный формат IEEE). 

> **Ахтунг**
>
> Числа с плавающей точкой имеют ограниченную точность. Хотя это зависит от операционной системы, 
в PHP обычно используется формат двойной точности, дающий максимальную относительную ошибку округления порядка 1.11e-16.
Это может привести к неожиданным результатам: например, `floor((0.1+0.7)*10)` скорее всего вернет 7 вместо ожидаемого 8, 
так как результат внутреннего представления будет чем-то вроде 7.9999999999999991118.

* Если строка начинается с верного числового значения, будет использовано это значение. 
  Иначе значением будет 0 (ноль). 
* Для значений других типов преобразование будет сначала осуществлено в тип integer, а затем в число с плавающей точкой.


Как указано выше, проверять числа с плавающей точкой на равенство проблематично из-за их внутреннего представления. 
Тем не менее, существуют способы для их сравнения, которые работают несмотря на все эти ограничения.

`$a` и `$b` равны до 5-ти знаков после запятой.

```php
<?php
$a = 1.23456789;
$b = 1.23456780;
$epsilon = 0.00001;

if (abs($a - $b) < $epsilon) {
    echo "true";
}
?>
```

### Строки

Строка (тип string) - это набор символов, где символ - это то же самое, что и байт.

> В PHP 7.0.0 на 64-битных платформах нет каких-либо достижимых ограничений для длины строки, в 32-битных системах и в более ранних версиях PHP, строки не могут быть более 2 ГБ (2147483647 байт).

Строка может быть определена четырьмя различными способами:

* одинарными кавычками 'Это строка'
* двойными кавычками "Это строка"
* heredoc-синтаксисом 
```php
<?php 
$str = <<<EOT
bar
EOT; // отступ перед закрывающим идентификатором недопустим 

$str = <<<MY_STRING
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я вывожу {$foo->bar[1]}.
Это должно вывести заглавную букву 'A': \x41
MY_STRING;

$str = <<<IDENT
bar
 IDENT; // так строка не закончится после IDENT 
?>
```
* nowdoc-синтаксисом - это то же самое для строк в одинарных кавычках, что и heredoc для строк в двойных кавычках. 
Nowdoc похож на heredoc, но внутри него не осуществляется никаких подстановок.
```php
<?php
echo <<<'EOD'
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я вывожу {$foo->bar[1]}.
Это должно вывести заглавную букву 'A': \x41
EOD;
?>
``` 

Если строка указывается в двойных кавычках, либо при помощи heredoc, переменные внутри нее обрабатываются.

Символы в строках можно использовать и модифицировать, определив их смещение относительно начала строки, начиная с нуля, в квадратных скобках после строки, например, `$str[42]`. 
Думайте о строке для этой цели, как о массиве символов. 
Если нужно получить или заменить более 1 символа, можно использовать функции `substr()` и `substr_replace()`.

Строки могут быть объединены при помощи оператора конкатенации `'.'`.

Значение может быть преобразовано в строку с помощью приведения `(string)`, либо функции `strval()`. 
В выражениях, где необходима строка, преобразование происходит автоматически. 
Это происходит, когда вы используете функции `echo` или `print`, либо когда значение переменной сравнивается со строкой. 

* Значение boolean TRUE преобразуется в строку "1", а значение FALSE преобразуется в ""
* Целое (integer) или число с плавающей точкой (float) преобразуется в строку, представленную числом, состоящим из его цифр
* Массивы всегда преобразуются в строку "Array"
* Для преобразования переменной типа "Object" в тип string используется магический метод __toString
* Тип ресурс (resource) всегда всегда преобразуется в строку (string) вида "Resource id #1"
* Значение NULL всегда преобразуется в пустую строку
* 

Для вывода полезной информации о любой переменной в строковом виде можно использовать функции `var_dump()` и `print_r()`.

### Массивы

Массив в PHP - это упорядоченное отображение, которое устанавливает соответствие между значением и ключом. 
Так как значением массива может быть другой массив PHP, можно также создавать многомерные массивы.

```php
<?php
$array = [];

$array = array();

$array = array(
    "bar",
    "foo",
);

$array = [
    "foo" => "bar",
    "bar" => "foo",
];


$array = [
    1 => 123,
    "foo" => "bar",
    'arr' => [1, 2, 3]
];

$arr["foo"] = 'foo';
?>
```

Ключ массива может быть либо типа integer, либо типа string. Значение может быть любого типа.

Ключ является необязательным. Если он не указан, PHP будет использовать предыдущее наибольшее значение ключа типа integer, увеличенное на 1.

Доступ к элементам массива может быть осуществлен с помощью синтаксиса `array[key]`.

```php
<?php
$array = array(
    "foo" => "bar",
    42    => 24,
    'arr' => [1, 2, 3]
);

var_dump($array["foo"]);
var_dump($array[42]);
var_dump($array["arr"][0]);
?>
```

Для любого из типов integer, float, string, boolean и resource, преобразование значения в массив дает результатом массив с одним элементом (с индексом 0), являющимся скалярным значением, с которого вы начали. 
Другими словами, `(array)$scalarValue` - это точно то же самое, что и `array($scalarValue)`.

Если вы преобразуете в массив значение NULL, вы получите пустой массив.


### Итерируемые

Iterable - псевдотип, введенный в PHP 7.1. Он принимает любой массив (array) или объект, реализующий интерфейс Traversable. 
Нужен для указания, что переменная итерируются с помощью foreach и может быть использована с yield from в генераторах.

### Объекты

Для создания нового объекта, используйте выражение new, создающее в переменной экземпляр класса:

```php
<?php
class foo
{
    function do_something()
    {
        echo "Код foo."; 
    }
}

$bar = new foo;
$bar->do_something();
?>
```

Если object преобразуется в object, объект не изменится. Если значение другого типа преобразуется в object, создается новый экземпляр встроенного класса stdClass. 
Если значение было NULL, новый экземпляр будет пустым. 
Массивы преобразуются в object с именами полей, названными согласно ключам массива и соответствующими им значениям.

```php
<?php
$obj = (object) ['test' => 'foo'];
var_dump($obj->test); // выведет 'foo'
?>
```

При преобразовании любого другого значения, оно будет помещено в поле с именем *scalar* соответствующему типу.

```php
<?php
$obj = (object) 'привет';
echo $obj->scalar;  // выведет 'привет'
?>
```

### Ресурс

Resource - это специальная переменная, содержащая ссылку на внешний ресурс. 
Ресурсы создаются и используются специальными функциями.

Поскольку тип resource содержит специальные указатели на открытые файлы, соединения с базой данных, 
области изображения и тому подобное, преобразование в этот тип не имеет смысла.

### NULL

Специальное значение NULL представляет собой переменную без значения. 
NULL - ~~он и в Африке null~~ это единственно возможное значение типа null.

Переменная считается null, если:

* ей была присвоена константа NULL.
* ей еще не было присвоено никакого значения.
* она была удалена с помощью unset().

```php
<?php
$var = NULL;
// или
$var = null;
?>
```

### Функции обратного вызова (callback-функции)

Некоторые функции, такие как call_user_func() или usort(), принимают определенные пользователем callback-функции в качестве параметра. 
Callback-функции могут быть как простыми функциями, так и методами объектов, включая статические методы классов.

В PHP функции передаются по имени в виде строки. Можно использовать любые встроенные, либо созданные пользователем функции, 
за исключением конструкций языка, таких как: `array()`, `echo`, `empty()`, `eval()`, `exit()`, `isset()`, `list()`, `print` или `unset()`.

Помимо обычных пользовательских функций, в качестве callback-функции можно передавать анонимные функции.

```php
<?php
// Пример callback-функции
function my_callback_function() {
    echo 'Привет, мир!';
}

call_user_func('my_callback_function');

call_user_func(function () {
   echo 'Привет, мир!';
});
?>
```


