# [Основы синтаксиса и типы](https://www.php.net/manual/ru/language.types.php)

## Синтаксис

Когда PHP обрабатывает файл, он ищет открывающие и закрывающие теги `<?php ... ?>`, которые указывают PHP, когда начинать и заканчивать обработку кода между ними. Подобный способ обработки позволяет PHP внедряться во все виды различных документов, так как всё, что находится вне пары открывающих и закрывающих тегов, будет проигнорировано парсером PHP.

Если файл содержит только код PHP, предпочтительно опустить закрывающий тег в конце файла. Это помогает избежать добавления случайных символов пробела или перевода строки после закрывающего тега PHP, которые могут послужить причиной нежелательных эффектов, так как PHP начинает выводить данные в буфер при отсутствии намерения у программиста выводить какие-либо данные в этой точке скрипта.

```php
<?php 
    echo 'если вы хотите хранить код PHP в документах HTML или XML, то используйте эти теги'; 
?>
```

Вы также можете встретить короткие теги  `<? ... ?>`, которые лучше не использовать, так как для этого необходимо дополнительно настраивать php. По умолчанию они отключены.

Кроме того очень удобно использовать комбинорование тега открытия `<?php` и тега вывода `echo`:

```php
<?= 'напечатать эту строку' ?>
или
<?php echo 'напечатать эту строку' ?>
```

PHP требует окончания инструкций точкой запятой в конце каждой инструкции. 

Закрывающий тег блока PHP-кода автоматически применяет точку с запятой; т.е. нет необходимости ставить точку с запятой в конце последней строки блока с PHP-кодом.

PHP поддерживает комментарии в стиле 'C', 'C++' и оболочки Unix (стиль Perl). Например:

```php
<?php
    echo "..."; // Это однострочный комментарий в стиле C++
    /* Это многострочный комментарий,
       еще одна строка комментария */
    echo "..."; # Это комментарий в стиле оболочки Unix
?>
```

Многострочные комментарии нельзя вкладывать друг в друга, так как комментарий заканчивается при первом же закрывающем символе `*/`

```php
<?php
 /*
    echo "Это тест"; /* Этот комментарий вызовет проблему */
 */
?>
```

## Типы

PHP - нестрого типизированный язык. 

Как правило, программист не устанавливает тип переменной; обычно это делает PHP во время выполнения программы в зависимости от контекста, в котором используется переменная.

Это означает, что мы можем использовать одну и ту же переменную для присвоения значений разных типов.

Например, сначала присвоили строковое значение, затем перезаписали его массивом, а затем целым числом.

PHP поддерживает десять простых типов.

Четыре скалярных типа:

* boolean
* integer
* float (число с плавающей точкой)
* string

Четыре смешанных типа:

* array
* object
* callable
* iterable

И два специальных типа:

* resource
* NULL

### Boolean

Логический тип данных, или булевый тип выражает истинность значения. Он может принимать значение TRUE, либо FALSE.

Для указания boolean, используюся константы `TRUE` или `FALSE`. Обе они регистронезависимы.

При преобразовании в boolean, следующие значения рассматриваются как FALSE:

* само значение boolean FALSE
* integer 0 (ноль) и -0 (минус ноль)
* float 0.0 (ноль) и -0.0 (минус ноль)
* пустая строка, и строка "0"
* массив без элементов
* особый тип NULL (включая неустановленные переменные)

Все остальные значения рассматриваются как TRUE.

### Целые числа

Это числа из множества -N ..., -2, -1, 0, 1, 2, ... N.

Размер типа integer зависит от платформы, хотя, как правило, максимальное значение примерно равно 2 миллиардам (это 32-битное знаковое). 
64-битные платформы обычно имеют максимальное значение около 9E18, кроме Windows, которая всегда 32-битная.

Если PHP обнаружит, что число превышает размер типа integer, он будет интерпретировать его в качестве float. 
Аналогично, если результат операции лежит за границами типа integer, он будет преобразован во float.

Для явного преобразования в integer, используйте приведение `(int)123` или `(integer)123`. Однако, в большинстве случаев, в приведении типа нет необходимости, 
так как значение будет автоматически преобразовано, если оператор, функция или управляющая структура требует аргумент типа integer. 
Значение также может быть преобразовано в integer с помощью функции `intval('123')`.

* FALSE преобразуется в 0 (ноль), а TRUE - в 1 (единицу)
* Значение NULL всегда преобразуется в 0 (ноль)
* При преобразовании из float в integer, число будет округлено в сторону нуля
* Если строка начинается с верного числового значения, будет использовано это значение. 
Иначе значением будет 0 (ноль). 

*Для других типов поведение преобразования в integer не определено.*

### Числа с плавающей точкой

Числами с плавающей точкой для простоты назовем числа с дробной частью.

Размер числа с плавающей точкой зависит от платформы, хотя максимум, как правило, 
составляет 1.8e308 с точностью около 14 десятичных цифр (64-битный формат IEEE). 

> **Ахтунг**
>
> Числа с плавающей точкой имеют ограниченную точность. Хотя это зависит от операционной системы, 
в PHP обычно используется формат двойной точности, дающий максимальную относительную ошибку округления порядка 1.11e-16.
Это может привести к неожиданным результатам: например, `floor((0.1+0.7)*10)` скорее всего вернет 7 вместо ожидаемого 8, 
так как результат внутреннего представления будет чем-то вроде 7.9999999999999991118.

* Если строка начинается с верного числового значения, будет использовано это значение. 
  Иначе значением будет 0 (ноль). 
* Для значений других типов преобразование будет сначала осуществлено в тип integer, а затем в число с плавающей точкой.


Как указано выше, проверять числа с плавающей точкой на равенство проблематично из-за их внутреннего представления. 
Тем не менее, существуют способы для их сравнения, которые работают несмотря на все эти ограничения.

`$a` и `$b` равны до 5-ти знаков после запятой.

```php
<?php
$a = 1.23456789;
$b = 1.23456780;
$epsilon = 0.00001;

if (abs($a - $b) < $epsilon) {
    echo "true";
}
?>
```

### Строки

Строка (тип string) - это набор символов, где символ - это то же самое, что и байт.

> В PHP 7.0.0 на 64-битных платформах нет каких-либо достижимых ограничений для длины строки, в 32-битных системах и в более ранних версиях PHP, строки не могут быть более 2 ГБ (2147483647 байт).

Строка может быть определена четырьмя различными способами:

* одинарными кавычками 'Это строка'
* двойными кавычками "Это строка"
* heredoc-синтаксисом 
```php
$str = <<<EOT
bar
EOT; // отступ перед закрывающим идентификатором недопустим 

$str = <<<MY_STRING
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я вывожу {$foo->bar[1]}.
Это должно вывести заглавную букву 'A': \x41
MY_STRING;

$str = <<<IDENT
bar
 IDENT; // так строка не закончится после IDENT 
```
* nowdoc-синтаксисом - это то же самое для строк в одинарных кавычках, что и heredoc для строк в двойных кавычках. 
Nowdoc похож на heredoc, но внутри него не осуществляется никаких подстановок.
```php
<?php
echo <<<'EOD'
Меня зовут "$name". Я печатаю $foo->foo.
Теперь я вывожу {$foo->bar[1]}.
Это должно вывести заглавную букву 'A': \x41
EOD;
``` 

Если строка указывается в двойных кавычках, либо при помощи heredoc, переменные внутри нее обрабатываются.

Символы в строках можно использовать и модифицировать, определив их смещение относительно начала строки, начиная с нуля, в квадратных скобках после строки, например, `$str[42]`. 
Думайте о строке для этой цели, как о массиве символов. 
Если нужно получить или заменить более 1 символа, можно использовать функции `substr()` и `substr_replace()`.

Строки могут быть объединены при помощи оператора конкатенации `'.'`.

Значение может быть преобразовано в строку с помощью приведения `(string)`, либо функции `strval()`. 
В выражениях, где необходима строка, преобразование происходит автоматически. 
Это происходит, когда вы используете функции `echo` или `print`, либо когда значение переменной сравнивается со строкой. 

* Значение boolean TRUE преобразуется в строку "1", а значение FALSE преобразуется в ""
* Целое (integer) или число с плавающей точкой (float) преобразуется в строку, представленную числом, состоящим из его цифр
* Массивы всегда преобразуются в строку "Array"
* Для преобразования переменной типа "Object" в тип string используется магический метод __toString
* Тип ресурс (resource) всегда всегда преобразуется в строку (string) вида "Resource id #1"
* Значение NULL всегда преобразуется в пустую строку
* 

Для вывода полезной информации о любой переменной в строковом виде можно использовать функции `var_dump()` и `print_r()`.

### Массивы

Массив в PHP - это упорядоченное отображение, которое устанавливает соответствие между значением и ключом. 
Так как значением массива может быть другой массив PHP, можно также создавать многомерные массивы.

```php
<?php
$array = [];

$array = array();

$array = array(
    "bar",
    "foo",
);

$array = [
    "foo" => "bar",
    "bar" => "foo",
];


$array = [
    1 => 123,
    "foo" => "bar",
    'arr' => [1, 2, 3]
];

$arr["foo"] = 'foo';
?>
```

Ключ массива может быть либо типа integer, либо типа string. Значение может быть любого типа.

Ключ является необязательным. Если он не указан, PHP будет использовать предыдущее наибольшее значение ключа типа integer, увеличенное на 1.

Доступ к элементам массива может быть осуществлен с помощью синтаксиса `array[key]`.

```php
<?php
$array = array(
    "foo" => "bar",
    42    => 24,
    'arr' => [1, 2, 3]
);

var_dump($array["foo"]);
var_dump($array[42]);
var_dump($array["arr"][0]);
?>
```

Для любого из типов integer, float, string, boolean и resource, преобразование значения в массив дает результатом массив с одним элементом (с индексом 0), являющимся скалярным значением, с которого вы начали. 
Другими словами, `(array)$scalarValue` - это точно то же самое, что и `array($scalarValue)`.

Если вы преобразуете в массив значение NULL, вы получите пустой массив.


### Итерируемые

Iterable - псевдотип, введенный в PHP 7.1. Он принимает любой массив (array) или объект, реализующий интерфейс Traversable. 
Нужен для указания, что переменная итерируются с помощью foreach и может быть использована с yield from в генераторах.

### Объекты

Для создания нового объекта, используйте выражение new, создающее в переменной экземпляр класса:

```php
<?php
class foo
{
    function do_something()
    {
        echo "Код foo."; 
    }
}

$bar = new foo;
$bar->do_something();
?>
```
