# [Константы](https://www.php.net/manual/ru/language.constants.php)

Константа - это идентификатор (имя) для простого значения. 
Как следует из названия, их значение не может изменится в ходе выполнения скрипта. 
Имена констант по умолчанию чувствительны к регистру. 
По принятому соглашению, имена констант всегда пишутся в верхнем регистре.

Имя константы должно соответствовать тем же правилам именования, что и другие имена в PHP.

Опредилить константу можно двумя способами:

```php
<?php
define("HELLO_WORLD", "Hello world.");
const HELLO_JOHN = 'Hello John Doe.';

var_dump(HELLO_WORLD, HELLO_JOHN);
?>
```

В отличие от определения констант с помощью функции `define()`, константы, 
объявленные с помощью ключевого слова `const` должны быть объявлены в самой верхней области видимости, 
потому что они определяются при компилировании скрипта. Это означает, что их нельзя объявлять внутри функций, 
циклов, выражений `if` и блоков `try/catch`.

Константы могут содержать скалярные данные (типы `boolean`, `integer`, `float` и `string`), 
возможно определить константу как скалярное выражение и `array`.

Вы можете использовать функцию `constant()` для получения значения константы, если вы формируете имя константы динамически. 
Используйте функцию `get_defined_constants()` для получения списка всех определенных констант.

```php
<?php
define("HELLO_WORLD", "Hello world.");
const HELLO_JOHN = 'Hello John Doe.';
$hello = 'HELLO_WORLD';
var_dump(constant($hello));
var_dump(get_defined_constants(true));
?>
```

Если вы просто хотите проверить, определена ли константа, используйте функцию `defined()`.

```php
<?php
define("HELLO_WORLD", "Hello world.");
var_dump(defined("HELLO_WORLD"), defined("HELLO_VLAD"));
?>
```
## Волшебные константы

Есть девять магических констант (на самом деле не совсем константы, так как могут менять свое значение, в зависимости от контекста вызова), 
которые меняют свое значение в зависимости от контекста, в котором они используются. 
Например, значение `__LINE__` зависит от строки в скрипте, на которой эта константа указана.

Имя|Описание
---|--------
\_\_LINE__|Текущий номер строки в файле.
\_\_FILE__|Полный путь и имя текущего файла с развернутыми симлинками. Если используется внутри подключаемого файла, то возвращается имя данного файла.
\_\_DIR__|Директория файла. Если используется внутри подключаемого файла, то возвращается директория этого файла. Это эквивалентно вызову dirname(__FILE__). Возвращаемое имя директории не оканчивается на слеш, за исключением корневой директории.
\_\_FUNCTION__|Имя функции или {closure} в случае анонимной функции.
\_\_CLASS__|Имя класса. Это имя содержит название пространства имен, в котором класс был объявлен (например, Foo\Bar). Обратите внимание, что начиная с PHP 5.4 __CLASS__ также работает в трейтах. При использовании в методах трейтов __CLASS__ является именем класса, в котором эти методы используется.
\_\_TRAIT__|Имя трейта. Это имя содержит название пространства имен, в котором трейт был объявлен (например, Foo\Bar).
\_\_METHOD__|Имя метода класса.
\_\_NAMESPACE__|Имя текущего пространства имен.
ClassName::class|Полное имя класса (с указанием пространства имен). См. также ::class.

# [Переменные](https://www.php.net/manual/ru/language.variables.php)

Переменные в PHP представлены знаком доллара с последующим именем переменной. 
Имя переменной чувствительно к регистру.

Имена переменных соответствуют тем же правилам, что и остальные наименования в PHP. 
Правильное имя переменной должно начинаться с буквы или символа подчеркивания и состоять из букв, 
цифр и символов подчеркивания в любом количестве.

```php
<?php 
$var = 1;
$VAR = 2;
$Var = 3;
$vaR = 4;
$vAr = 5;

$var = 10;

var_dump($var, $VAR, $Var, $vaR, $vAr);

$4site = 1;     // ошибка; начинается с цифры
$_4site = 1;    // верно; начинается с символа подчеркивания
?>
```

[Руководство по именованию](https://www.php.net/manual/ru/userlandnaming.php)

[Функции для работы с переменными](https://www.php.net/manual/ru/ref.var.php)

По умолчанию переменные всегда присваиваются по значению. То есть, когда вы присваиваете выражение переменной, 
все значение оригинального выражения копируется в эту переменную. Это означает, 
к примеру, что после того как одной переменной присвоено значение другой, изменение одной из них не влияет на другую.

PHP также предлагает иной способ присвоения значений переменным: присвоение по ссылке. 
Это означает, что новая переменная просто ссылается (иначе говоря, "становится псевдонимом" или "указывает") 
на оригинальную переменную. Изменения в новой переменной отражаются на оригинале, и наоборот.

Для присвоения по ссылке, просто добавьте амперсанд (&) к началу имени присваиваемой (исходной) переменной.

```php
<?php 
$name = 'John';               // Присваивает $foo значение 'John'
$fullName = &$name;           // Ссылка на $name через $fullName.
$fullName = "Doe ".$fullName; // Изменение $fullName...
var_dump($fullName);
var_dump($name);              // меняет и $name.
?>
```

## Предопределенные переменные

PHP предоставляет всем скриптам большое количество предопределённых переменных. 
Эти переменные содержат всё, от внешних данных до переменных среды окружения, 
от текста сообщений об ошибках до последних полученных заголовков.

* $GLOBALS — Ссылки на все переменные глобальной области видимости
* $_SERVER — Информация о сервере и среде исполнения
* $_GET — Переменные HTTP GET
* $_POST — Переменные HTTP POST
* $_FILES — Переменные файлов, загруженных по HTTP
* $_REQUEST — Переменные HTTP-запроса
* $_SESSION — Переменные сессии
* $_ENV — Переменные окружения
* $_COOKIE — HTTP Cookies

* $php_errormsg — Предыдущее сообщение об ошибке
* $HTTP_RAW_POST_DATA — Необработанные данные POST
* $http_response_header — Заголовки ответов HTTP
* $argc — Количество аргументов, переданных скрипту
* $argv — Массив переданных скрипту аргументов

## Область видимости переменной

Область видимости переменной - это контекст, в котором эта переменная определена. 
В большинстве случаев все переменные PHP имеют только одну область видимости. 
Эта единая область видимости охватывает также включаемые (include) и требуемые (require) файлы. 

Однако определение (тело) пользовательской функции задает локальную область видимости данной функции. 
Любая используемая внутри функции переменная по умолчанию ограничена локальной областью видимости функции.

```php
<?php
$a = 1; /* глобальная область видимости */ 

function test()
{ 
    $a = 5; /* локальная область видимости */
    echo $a . PHP_EOL;  
} 

test();
echo $a . PHP_EOL;

$a = 2;
echo $a . PHP_EOL;
test();
?>
```

## Использование статических (static) переменных

Статическая переменная существует только в локальной области видимости функции, 
но не теряет своего значения, когда выполнение программы выходит из этой области видимости. 

```php
<?php
function test()
{
    $a = 0;
    static $b = 0;

    echo 'a => ' . $a . PHP_EOL;
    $a++;

    echo 'b =>' .$b . PHP_EOL;
    $b++;

    echo PHP_EOL;
}
test();
test();
?>
```

Можно присвоить статическим переменным значения, являющиеся результатом выражения, 
но нельзя использовать для этого функцию, так это вызовет ошибку разбора.

```php
<?php
function foo() {
    static $int1 = 0;          // верно
    static $int2 = 1+2;        // верно
    static $int3 = sqrt(121);  // неверно (поскольку это функция)

    $int1++;
    echo $int1;
}
?>
```

## ~~Масло маслянное~~ Переменные переменных 

Иногда бывает удобно иметь переменными имена переменных. То есть, имя переменной, 
которое может быть определено и изменено динамически. 
Переменная переменной берет значение переменной и рассматривает его как имя переменной. (Какая дичь :man_facepalming:)

```php
<?php
$a = 'hello'; // обычная переменная
$$a = 'world'; // переменная переменной

var_dump($$a == $hello);
?>
```

Для того чтобы использовать переменные переменных с массивами, вы должны решить проблему двусмысленности. 
То есть, если вы напишете `$$a[1]`, обработчику необходимо знать, хотите ли вы использовать `$a[1]` в качестве переменной, 
либо вам нужна как переменная `$$a`, а затем ее индекс `[1]`. 
Синтаксис для разрешения этой двусмысленности таков: `${$a[1]}` для первого случая и `${$a}[1]` для второго.

## Переменные извне PHP

Когда мы из HTML формы отправляем данные на сервер, они становятся доступны PHP-скрипту.

```html
<form action="index.php" method="post">
    Имя:  <input type="text" name="username" /><br />
    Email: <input type="text" name="email" /><br />
    <input type="submit" name="submit" value="Отправь меня!" />
</form>
```

Существует два способа получить эти данные:

```php
<?php
echo $_POST['username'];
echo $_REQUEST['username'];
?>
```

GET-форма используется аналогично, за исключением того, что вместо POST, 
вам нужно будет использовать соответствующую предопределенную переменную GET.

Точки и пробелы в именах переменных преобразуется в знаки подчеркивания. 
Например, `<input name="a.b" />` станет `$_POST["a_b"]`.

PHP также понимает массивы в контексте переменных формы. 
Например, нам нужно отправить на сервер значений списка множественного выбора select.

```html
<form action="index.php" method="post">
   Пиво: <br />
   <select multiple name="beer[]">
       <option value="warthog">Warthog</option>
       <option value="guinness">Guinness</option>
       <option value="stuttgarter">Stuttgarter Schwabenbräu</option>
   </select><br />
   <input type="submit" value="Отправь меня!" />
</form>
```
Получить массив выбранных элементов можно так: 

```php
<?php
var_dump($_POST['beer']);
var_dump($_REQUEST['beer']);
?>
```

## HTTP Cookies

Cookies - это механизм для хранения данных в удаленном браузере и, таким образом, 
отслеживание и идентификации вернувшихся пользователей. Вы можете установить cookies, используя функцию `setcookie()`. 
Cookies являются частью HTTP-заголовка, поэтому функция `setcookie()` должна вызываться до того, 
как браузеру будет отправлен какой бы то ни было вывод. Это то же ограничение, что и для функции `header()`.
Данные, хранящиеся в cookie, доступны в соответствующих массивах данных cookie, таких как `$_COOKIE` и `$_REQUEST`.

```php
<?php
  setcookie("MyTestCookie", 'Testing 1', time()+3600);
  setcookie("MyCookie[test1]", 'Testing 1', time()+3600);
  setcookie("MyCookie[test2]", 'Testing 2', time()+3600);
  
  if (isset($_COOKIE['count'])) {
      $count = $_COOKIE['count'] + 1;
  } else {
      $count = 1;
  }
  setcookie('count', $count, time()+3600);
?>
```

## Определение типов переменных 

Поскольку PHP определяет типы переменных и преобразует их (как правило) по мере необходимости, не всегда очевидно, 
какой тип имеет данная переменная в любой момент времени. 
PHP содержит несколько функций, позволяющих определить тип переменной, 
таких как: `gettype()`, `is_array()`, `is_float()`, `is_int()`, `is_object()` и `is_string()`. 

HTTP является текстовым протоколом, и большинство, если не всё, содержимое, которое приходит в cуперглобальные массивы, 
например $_POST и $_GET, останется в виде строк. PHP не будет преобразовывать значения в определенный тип. 

```
/index.php?var1=null&var2=123
```

В приведенном ниже примере `$_GET["var1"]` будет содержать строку `"null"`, а `$_GET["var2"]` строку `"123"`.

